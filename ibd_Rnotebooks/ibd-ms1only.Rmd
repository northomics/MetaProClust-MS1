---
title: "IBD MS1-only"
output: html_notebook
---

Loading necessary libraryes

```{r, message=F, error=F}
library(renv) #remotes::install_github("rstudio/renv")
#renv::restore()
library(tidyverse)
library(stringr)
library(DESeq2)
library(data.table)
library(dendextend)
library(here)
library(impute)
library(pvclust)
library(gplots)
library(RColorBrewer)
library(cluster)
library(cutr)#devtools::install_github("moodymudskipper/cutr")
library(caret) 
library(mlbench)
library(MASS)
library(glmnet)
library(foreach)
library(doParallel)
registerDoParallel(cores=2)
library(stringr)
library(lubridate)
library(umap)
library(sva)
#renv::snapshot()
```

## Data input and normalization

Reading MS1 feature intensity data. We will need to subset to only include the consensus features. We'll also organize the samples by "Group" (ie Control, CD, UC)
```{r}    
### For the openMS files
## will have to edit...
## sample info ../data/ms1_openms_sampleinfo.csv
ibd_samples <- read.csv(here::here("ibd", "data", "ibd-nc-samples.csv"), header=F)
ibd_samples <- lapply(ibd_samples, trimws)
ms1_openms_metadata <- read.csv(here::here("ibd", "data", "ibd-nc-metadata.csv"))
intensity <- read.csv(here::here("ibd", "data", "ibd-nc_ms1intensity-20mins-100ppm.csv"), row.names=1)
ms_order <- read.csv(here::here("ibd", "data", "ms_order.txt"), sep="\t", header=F)
colnames(ms_order) <- c("Month", "Day", "Year", "File")
ms_order$Date <- paste(ms_order$Month, ms_order$Day, ms_order$Year) %>% mdy(.)
ms_order <- ms_order %>% arrange(., Date)


int_col <- data.frame(Sample.Name = colnames(intensity))
ibd_meta <- right_join(int_col, ms1_openms_metadata, by="Sample.Name") ## only including samples we used
ibd_meta <- ibd_meta %>% mutate(NewName = paste0(Sample.Name, "_", Diagnosis))

ms_order <- ms_order %>% mutate(basename = str_remove(File, ".raw")) %>%
  mutate(basename = str_remove(basename, "/"))
ibd_meta <- ms_order %>% merge(., ibd_samples,  by.y = "V2", by.x="basename", all.y=T) %>% merge(., ibd_meta, by.x="V6", by.y="Sample.Name", all.y=T)
## missing some dates, need to fill in manually
#write.csv(ibd_meta, file=here::here("ibd", "data", "ibd-nc-metadata_dates.csv"))


tryp1 <- intensity %>% filter(between(MZ, 576.0, 577.99)) %>% dplyr::select(feature_num) 
#final[complete.cases(final),]
tryp2 <- intensity %>% filter(between(MZ, 1081.0, 1082.99)) %>% dplyr::select(feature_num) 

## Want to remove TI site...
#ibd_meta <- ibd_meta %>% dplyr::filter(site != "TI")


## try to reduce number of features...
# reorganize df so that it's in the order of drugs (for filtering)
ibd_meta <- ibd_meta %>% arrange(., Diagnosis)
intensity_info <- intensity %>% dplyr::select(feature_num, RT,MZ)
intensity <- intensity %>% dplyr::select(ibd_meta$V6)
colnames(intensity) <- paste0(colnames(intensity), "_", ibd_meta$Diagnosis) 
intensity <- intensity %>% mutate(feat_num = 1:nrow(intensity))



#put_tryp1 <- intensity[tryp1$feature_num,]
#put_tryp1 <- put_tryp1[complete.cases(put_tryp1),]
#rowMeans(put_tryp1 %>% dplyr::select(-feat_num))
#put_tryp2 <- intensity[tryp2$feature_num,]
#put_tryp2 <- put_tryp2[complete.cases(put_tryp2),]

ibd_meta <- ibd_meta %>% mutate(Location = case_when(Intestinal.region == "Ascending colon" ~ "AC",
                                         Intestinal.region == "Terminal ileum" ~ "TI",
                                         Intestinal.region == "Descending colon" ~ "DC"))

## want to do these locations separately
AC_samples <- ibd_meta %>% filter(Location == "AC") 
TI_samples <- ibd_meta %>% filter(Location == "TI") 
DC_samples <- ibd_meta %>% filter(Location == "DC") 

#write.csv(AC_samples, here::here("ibd", "ac", "ac-files.csv"), quote=F)
#write.csv(TI_samples, here::here("ibd", "ti", "ti-files.csv"), quote=F)
#write.csv(DC_samples, here::here("ibd", "dc", "dc-files.csv"), quote=F)
```




We want to filter the data by missing values and low intensity values. MS1 data is inherently noisy, and so we also filter by low intensity. In this case, we identify intensity quartiles and consider the lowest quartile missing values **only** for the filtering step. We will keep these values for clustering. 

I believe there may be too many differences between intestinal regions so we should analyze these datasets separately.

```{r}


int_AC <- intensity %>% dplyr::select(AC_samples$NewName)
int_TI <- intensity %>% dplyr::select(TI_samples$NewName)
int_DC <- intensity %>% dplyr::select(DC_samples$NewName)

cond_options_all <- table(ibd_meta$Diagnosis) %>% as.data.frame()
cond_opts_all <- cond_options_all$Var1
cond_count_all <- cond_options_all$Freq * 0.5


cond_options_AC <- table(AC_samples$Diagnosis) %>% as.data.frame()
cond_options_TI <- table(TI_samples$Diagnosis) %>% as.data.frame()
cond_options_DC <- table(DC_samples$Diagnosis) %>% as.data.frame()
## options for drug specific filtering
## want to change intensities below a noise threshold for 
cond_opts_AC <- cond_options_AC$Var1
cond_count_AC <- cond_options_AC$Freq * 0.5

cond_opts_TI <- cond_options_TI$Var1
cond_count_TI <- cond_options_TI$Freq * 0.5

cond_opts_DC <- cond_options_DC$Var1
cond_count_DC <- cond_options_DC$Freq * 0.5
#intensity[25,]
#intensity[128,]

## Let's normalize intensity to a putative trysin peptide (row 1, or feature_num 1)

#intensity <- intensity %>% filter(feat_num != 1) #%>% dplyr::select(-RT, -MZ)
#
##intensity_norm <- sweep(intensity, 2, put_tryp1, "/") 
#put_tryp1 <- as.vector(put_tryp1 %>% dplyr::select(-feat_num))
#
#intensity <- as.matrix(intensity %>% dplyr::select(-feat_num))
#intensity[complete.cases(intensity),] %>% dim()
#
#test <- sweep(intensity, 2, as.matrix(put_tryp1), "/")

## we can reduce the number of features using intensity binning, but I don't believe it is necessary for the IBD data
#int <- intensity %>% as.data.frame %>% pivot_longer(names_to = "Name", values_to="intensity", cols=everything()) %>% drop_na()
#head(int)
#summary(int$intensity)
#int_4_quartiles <- smart_cut(int$intensity,4,"groups", labels = c("remove", "Low", "Med", "High"))
#table(int_4_quartiles)
#int$quart <- int_4_quartiles
#max_to_remove <- int %>% filter(quart == "remove")
#max_to_remove <- max_to_remove$intensity %>% max()
#
#dens <- density(log2(int$intensity))
#df <- data.frame(x=dens$x, y=dens$y)
#probs <- c(0,0.25,0.5,0.75,1)
#quantiles <- quantile(log2(int$intensity), prob=probs)
#df$quant <- factor(findInterval(df$x,quantiles))
#
#
#(pep_quart_plot <- ggplot(df, aes(x,y)) + geom_line() + 
#    geom_ribbon(aes(ymin=0, ymax=y, fill=quant)) + 
#    scale_x_continuous(breaks=quantiles) + 
#    #scale_fill_brewer(guide="none") +
#    xlab("MS1 feature intensities") +
#    ylab("Density") +
#    scale_fill_viridis_d(option = "plasma", guide = "none") +
#    theme_bw() +
#    theme(text=element_text(size=14)) 
#)
#
#
#ms_order %>% head(n=10)
#
### Match run order to meta data
#
#
#
###
#earlyruns <- intensity %>% dplyr::select(., matches("HM621PCA|HM621TIA|HM621TIN|HM504TIN|HM565TIN|HM421TI|HM421CO|HM565TIA|HM504PCA|HM565PCN")) #, HM621TIN, HM504TIN, HM565TIN, HM421TI
#
#int <- earlyruns %>% pivot_longer(names_to = "Name", values_to="intensity", cols=everything()) %>% drop_na()
#head(int)
#summary(int$intensity)
#int_4_quartiles <- smart_cut(int$intensity,4,"groups", labels = c("remove", "Low", "Med", "High"))
#table(int_4_quartiles)
#int$quart <- int_4_quartiles
#max_to_remove <- int %>% filter(quart == "remove")
#max_to_remove <- max_to_remove$intensity %>% max()
#
#dens <- density(log2(int$intensity))
#df <- data.frame(x=dens$x, y=dens$y)
#probs <- c(0,0.25,0.5,0.75,1)
#quantiles <- quantile(log2(int$intensity), prob=probs)
#df$quant <- factor(findInterval(df$x,quantiles))
#
#
#(pep_quart_plot <- ggplot(df, aes(x,y)) + geom_line() + 
#    geom_ribbon(aes(ymin=0, ymax=y, fill=quant)) + 
#    scale_x_continuous(breaks=quantiles) + 
#    #scale_fill_brewer(guide="none") +
#    xlab("MS1 feature intensities") +
#    ylab("Density") +
#    scale_fill_viridis_d(option = "plasma", guide = "none") +
#    theme_bw() +
#    theme(text=element_text(size=14)) 
#)
#
### can see that there is an issue with batches.
### we can normalize using highly abundant features across all samples
#full_quant <- rowSums(is.na(intensity))
#
#
#ggsave(here::here("figs", "ms1quart.pdf"), pep_quart_plot, width = 10, height = 6, units = "in")
### separating by Control, UC and CD
#int_CD <- int %>% filter(stringr::str_detect(Name, "CD"))
#
#int_4_quartiles <- smart_cut(int_CD$intensity,4,"groups", labels = c("remove", "Low", "Med", "High"))
#table(int_4_quartiles)
#int_CD$quart <- int_4_quartiles
#max_to_remove <- int_CD %>% filter(quart == "remove")
#max_to_remove <- max_to_remove$intensity %>% max()
#
#dens <- density(log2(int_CD$intensity))
#df <- data.frame(x=dens$x, y=dens$y)
#probs <- c(0,0.25,0.5,0.75,1)
#quantiles <- quantile(log2(int$intensity), prob=probs)
#df$quant <- factor(findInterval(df$x,quantiles))
#
#
#(pep_quart_plot <- ggplot(df, aes(x,y)) + geom_line() + 
#    geom_ribbon(aes(ymin=0, ymax=y, fill=quant)) + 
#    scale_x_continuous(breaks=quantiles) + 
#    #scale_fill_brewer(guide="none") +
#    xlab("MS1 feature intensities") +
#    ylab("Density") +
#    scale_fill_viridis_d(option = "plasma", guide = "none") +
#    theme_bw() +
#    theme(text=element_text(size=14)) 
#)
#
##ggsave(here::here("figs", "ms1quart.pdf"), pep_quart_plot, width = 10, height = 6, units = "in")

is.nan.data.frame <- function(x){
    do.call(cbind, lapply(x, is.nan))}
#df = intensity
#conditions = cond_opts
#min_count = cond_count
## add condition to end of all col names...
filter_valids_quart = function(df, conditions, min_count, int_remove, at_least_one = TRUE) {
    df[is.nan.data.frame(df)] <- 0
    df[is.na(df)] <- 0
    df[df <= int_remove] <- 0
    all_names <- colnames(df) 
    cond.names = lapply(conditions, # Group column names by conditions
                        function(x) grep(x, all_names, value = TRUE, perl = TRUE))
    cond.filter = sapply(1:length(cond.names), function(i) {
        df2 = df %>% dplyr::select(cond.names[[i]])   # Extract columns of interest
        df2 = as.matrix(df2)   # Cast as matrix for the following command
        sums = rowSums(df2!=0) # count the number of valid values for each condition
        sums >= min_count[i]   # Calculates whether min_count requirement is met
    })
    if (at_least_one) {
        df$KEEP = apply(cond.filter, 1, any)
    } else {
        df$KEEP = apply(cond.filter, 1, all)
    }
    return(df)  # only keeping rows that meet the criteria!
}

 

## filter by at least Q50 in each treatment considering ZEROS and anything in low quartile
## trying without any quartile adjustment!
ibd_filt_all <- filter_valids_quart(intensity[,-177], 
                               conditions = cond_opts_all,
                               min_count = cond_count_all, 
                               int_remove = 1,
                               at_least_one = T) #235,216
ibd_filt_all <- intensity[ibd_filt_all$KEEP == 1,-177] ## 20,820
all_filt_feat <- rownames(ibd_filt_all)


ibd_filt_DC <- filter_valids_quart(int_DC, 
                               conditions = cond_opts_DC,
                               min_count = cond_count_DC, 
                               int_remove = 1,
                               at_least_one = T) #235,216
ibd_filt_DC <- int_DC[ibd_filt_DC$KEEP == 1,] ## 25,952
DC_filt_feat <- rownames(ibd_filt_DC)



ibd_filt_AC <- filter_valids_quart(int_AC, 
                               conditions = cond_opts_AC,
                               min_count = cond_count_AC, 
                               int_remove = 1,
                               at_least_one = T) #235,216
ibd_filt_AC <- int_AC[ibd_filt_AC$KEEP == 1,] ## 23,804
AC_filt_feat <- rownames(ibd_filt_AC)

ibd_filt_TI <- filter_valids_quart(int_TI, 
                               conditions = cond_opts_TI,
                               min_count = cond_count_TI, 
                               int_remove = 1,
                               at_least_one = T) #235,216
ibd_filt_TI <- int_TI[ibd_filt_TI$KEEP == 1,] ## 23,716
TI_filt_feat <- rownames(ibd_filt_TI)



## can further explore features if needed!!

#is.nan(intensity) <- 0
norm_feat_all <- estimateSizeFactorsForMatrix(ibd_filt_all)
norm_int_all <- sweep(ibd_filt_all, 2, norm_feat_all, "/") ##peptides are normalized

norm_feat_TI <- estimateSizeFactorsForMatrix(ibd_filt_TI)
norm_int_TI <- sweep(ibd_filt_TI, 2, norm_feat_TI, "/") ##peptides are normalized

norm_feat_AC <- estimateSizeFactorsForMatrix(ibd_filt_AC)
norm_int_AC <- sweep(ibd_filt_AC, 2, norm_feat_AC, "/") ##peptides are normalized

norm_feat_DC <- estimateSizeFactorsForMatrix(ibd_filt_DC)
norm_int_DC <- sweep(ibd_filt_DC, 2, norm_feat_DC, "/") ##peptides are normalized
```

## Missing data imputation

Although we filtered data, we are still left with missing values that will cause challenges with log transformation and fold change calculations. We used a KNN data imputation.

```{r, message=F, warning=F}
## impute missing values
#intensity_0 <- intensity %>%  mutate_all(~replace(., is.nan(.), 0))

imputed_pep_all<- impute.knn(norm_int_all %>% as.matrix(), k = 10, rowmax = 0.5, colmax = 0.95, rng.seed = 362436069)

#imputed_pep_DC<- impute.knn(norm_int_DC %>% as.matrix(), k = 10, rowmax = 0.5, colmax = 0.95, rng.seed = 362436069)

#imputed_pep_AC<- impute.knn(norm_int_AC %>% as.matrix(), k = 10, rowmax = 0.5, colmax = 0.95, rng.seed = 362436069)

#imputed_pep_TI<- impute.knn(norm_int_TI %>% as.matrix(), k = 10, rowmax = 0.5, colmax = 0.95, rng.seed = 362436069)


```
## Batch effect?

The IBD samples were run on the MS/MS years apart. This means we may expect some sort of batch effect to emerge. There were no specific "batches", but we will probably need to adjust for some differences due to time of year, changes in columns, etc.

Let's use UMAP on the unfiltered and un-normalized data to see if we can find any clusters that we would not expect.


```{r}
ms1_umap_all <- umap(imputed_pep_all$data %>% as.matrix %>% t(), n_components=2, random_state=2248)
#ibd_meta <- ibd_meta[match(colnames(log_exp), ibd_meta$NewName),]
coords_umap_all<-data.frame(ms1_umap_all$layout, Diagnosis = ibd_meta$Diagnosis,
                   #samplename = colnames(log_exp_DC),
                   Sex = ibd_meta$Gender,
                   Site = ibd_meta$Location,
                   Inflammed = ibd_meta$Inflammed, Date=ibd_meta$Date)
coords_umap_all$Diagnosis <- factor(coords_umap_all$Diagnosis, levels = c("Control", "UC", "CD"))
coords_umap_all$Inflammed <- factor(coords_umap_all$Inflammed, levels = c("Yes","No"))
labels <- pretty(coords_umap_all$Date, 5)
(umap_plot_all_diag <- ggplot(coords_umap_all, aes(x = X1, y = X2)) +
        geom_point(size=5, aes(shape = Site, color = Diagnosis)) + 
        scale_color_manual(values=c("#8FBFE0", "#F57251",  "#3444DA")) +
        #scale_color_gradient(
  #  low="yellow", high="purple", 
  #  breaks = as.integer(labels), 
  #  labels = format(labels, "%m/%d/%y")
 # ) +
        scale_x_continuous(name="UMAP1") + 
        scale_y_continuous(name="UMAP2") +
        #theme_bw() +
        theme(legend.position = "right", text=element_text(size=16)))

(umap_plot_all <- ggplot(coords_umap_all, aes(x = X1, y = X2)) +
        geom_point(size=5, aes(shape = Diagnosis, color = Date)) + 
        #scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
        scale_color_gradient(
    low="yellow", high="purple", 
    breaks = as.integer(labels), 
    labels = format(labels, "%m/%d/%y")
  ) +
        scale_x_continuous(name="UMAP1") + 
        scale_y_continuous(name="UMAP2") +
        #theme_bw() +
        theme(legend.position = "right", text=element_text(size=16)))
#ggsave(filename = "../figs/umap-ibd-diagnosis.pdf", umap_plot_all_diag, width = 8, height = 6, units = "in")
#ggsave(filename = "../figs/umap-ibd-date.pdf", umap_plot_all, width = 8, height = 6, units = "in")
```



## Log2 intensity transformation and PCA quality check

We then should log transform the intensity values and perform a PCA for a QC check.




```{r, message=F, warning=F}
## easy and quick PCA funcDCon for manual colour and shape
quick_pca_date <- function(coords_df, x_PC, y_PC, PoV, shape, fill){
    yaxis <- y_PC
    xaxis <- x_PC
    yperc <- paste0("(", round(PoV[yaxis %>% as.numeric()] ,2), "%)")
    xperc <- paste0("(", round(PoV[xaxis %>% as.numeric()] ,2), "%)")
    yaxislabel <- paste0("PC", yaxis, " ", yperc)
    xaxislabel <- paste0("PC", xaxis, " ", xperc)
    pca_plot <- ggplot(coords_df, aes_string(x = paste0('PC', xaxis), y = paste0('PC', yaxis))) +
        geom_point(size=4, aes_string(shape = shape, color = fill)) + 
        #scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
  scale_color_gradient(
    low="yellow", high="purple", 
    breaks = as.integer(labels), 
    labels = format(labels, "%m/%d/%y")
  ) +
      scale_x_continuous(name=xaxislabel) + 
        scale_y_continuous(name=yaxislabel) +
        theme_bw() +
        theme(legend.position = "right", text=element_text(size=16))
    return(pca_plot)
}


log_exp_all <- data.frame(imputed_pep_all$data) %>%
    mutate_all(., funs(log2(1 + .)))
colnames(log_exp_all) = colnames(imputed_pep_all$data)
pca_all<- prcomp(log_exp_all %>% t(), center=T, scale=F)
sampleVals_all<-data.frame(pca_all$x)
exprVals_all<-data.frame(pca_all$rotation)
PoV_all <- (pca_all$sdev^2/sum(pca_all$sdev^2))*100 

coords_all<-data.frame(sampleVals_all, Group = ibd_meta$Diagnosis,
                   samplename = rownames(sampleVals_all),
                   Sex = ibd_meta$Gender,
                   Site = ibd_meta$Location,
                   Inflammed = ibd_meta$Inflammed, Date=ibd_meta$Date) #,
                   #Age = ibd_meta$Age)
coords_all$Group <- factor(coords_all$Group, levels = c("Control", "UC", "CD"))
numPCs_all <- 1:length(PoV_all)

for (i in 1:length(PoV_all)) {
    percent <- paste0("(", round(PoV_all[i],2), "%)")
    name <- paste0("PC", i, "per")
    assign(name, percent)
}
(pc12_all <- quick_pca(coords_df = coords_all, x_PC = 2, y_PC = 1, PoV = PoV_DC, shape = "Site", fill = "Group"))

(pc12_all <- quick_pca_date(coords_df = coords_all, x_PC = 2, y_PC = 1, PoV = PoV_DC, shape = "Group", fill = "Date"))

(pc23_all <- quick_pca(coords_df = coords_all, x_PC = 2, y_PC = 3, PoV = PoV_DC, shape = "Inflammed", fill = "Group"))

(pc23_all <- quick_pca_date(coords_df = coords_all, x_PC = 2, y_PC = 3, PoV = PoV_DC, shape = "Group", fill = "Date"))
```

### Descending colon region 

```{r}
log_exp_DC <- data.frame(imputed_pep_DC$data) %>%
    mutate_all(., funs(log2(1 + .)))
colnames(log_exp_DC) = colnames(imputed_pep_DC$data)
pca_DC<- prcomp(log_exp_DC %>% t(), center=T, scale=F)
sampleVals_DC<-data.frame(pca_DC$x)
exprVals_DC<-data.frame(pca_DC$rotaDCon)
PoV_DC <- (pca_DC$sdev^2/sum(pca_DC$sdev^2))*100 

coords_DC<-data.frame(sampleVals_DC, Group = DC_samples$Diagnosis,
                   samplename = rownames(sampleVals_DC),
                   Sex = DC_samples$Gender,
                   Site = DC_samples$Intestinal.region,
                   Inflammed = DC_samples$Inflammed, Date=DC_samples$Date) #,
                   #Age = ibd_meta$Age)
coords_DC$Group <- factor(coords_DC$Group, levels = c("Control", "UC", "CD"))
numPCs_DC <- 1:length(PoV_DC)

for (i in 1:length(PoV_DC)) {
    percent <- paste0("(", round(PoV_DC[i],2), "%)")
    name <- paste0("PC", i, "per")
    assign(name, percent)
}

(pc12_DC <- quick_pca(coords_df = coords_DC, x_PC = 2, y_PC = 1, PoV = PoV_DC, shape = "Inflammed", fill = "Group"))
(pc12_DC <- quick_pca_date(coords_df = coords_DC, x_PC = 2, y_PC = 1, PoV = PoV_DC, shape = "Group", fill = "Date"))


(pc23_DC <- quick_pca(coords_df = coords_DC, x_PC = 2, y_PC = 3, PoV = PoV_DC, shape = "Inflammed", fill = "Group"))

#ggsave(filename = "../figs/ms2-pc12-full.pdf", pc12, width = 8, height = 6, units = "in")
```
### Ascending colon region 

```{r, message=F, warning=F}
log_exp_AC <- data.frame(imputed_pep_AC$data) %>%
    mutate_all(., funs(log2(1 + .)))
colnames(log_exp_AC) = colnames(imputed_pep_AC$data)
pca_AC<- prcomp(log_exp_AC %>% t(), center=T, scale=F)
sampleVals_AC<-data.frame(pca_AC$x)
exprVals_AC<-data.frame(pca_AC$rotation)
PoV_AC <- (pca_AC$sdev^2/sum(pca_AC$sdev^2))*100 

coords_AC<-data.frame(sampleVals_AC, Group = AC_samples$Diagnosis,
                   samplename = rownames(sampleVals_AC),
                   Sex = AC_samples$Gender,
                   Site = AC_samples$Intestinal.region,
                   Inflammed = AC_samples$Inflammed, Date=AC_samples$Date) #,
                   #Age = ibd_meta$Age)
coords_AC$Group <- factor(coords_AC$Group, levels = c("Control", "UC", "CD"))
numPCs_AC <- 1:length(PoV_AC)

for (i in 1:length(PoV_AC)) {
    percent <- paste0("(", round(PoV_AC[i],2), "%)")
    name <- paste0("PC", i, "per")
    assign(name, percent)
}

## easy and quick PCA function for manual colour and shape
quick_pca <- function(coords_df, x_PC, y_PC, PoV, shape, fill){
    yaxis <- y_PC
    xaxis <- x_PC
    yperc <- paste0("(", round(PoV[yaxis %>% as.numeric()] ,2), "%)")
    xperc <- paste0("(", round(PoV[xaxis %>% as.numeric()] ,2), "%)")
    yaxislabel <- paste0("PC", yaxis, " ", yperc)
    xaxislabel <- paste0("PC", xaxis, " ", xperc)
    pca_plot <- ggplot(coords_df, aes_string(x = paste0('PC', xaxis), y = paste0('PC', yaxis))) +
        geom_point(size=4, aes_string(shape = shape, color = fill)) + 
        scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
        scale_x_continuous(name=xaxislabel) + 
        scale_y_continuous(name=yaxislabel) +
        theme_bw() +
        theme(legend.position = "right", text=element_text(size=16))
    return(pca_plot)
}
(pc12_AC <- quick_pca(coords_df = coords_AC, x_PC = 2, y_PC = 1, PoV = PoV_AC, shape = "Inflammed", fill = "Group"))

(pc23_AC <- quick_pca(coords_df = coords_AC, x_PC = 2, y_PC = 3, PoV = PoV_AC, shape = "Inflammed", fill = "Group"))

(pc23_AC <- quick_pca_date(coords_df = coords_AC, x_PC = 2, y_PC = 3, PoV = PoV_AC, shape = "Group", fill = "Date"))

#ggsave(filename = "../figs/ms2-pc12-full.pdf", pc12, width = 8, height = 6, units = "in")
```
### Terminal illium region 

```{r, message=F, warning=F}
log_exp_TI <- data.frame(imputed_pep_TI$data) %>%
    mutate_all(., funs(log2(1 + .)))
colnames(log_exp_TI) = colnames(imputed_pep_TI$data)
pca_TI<- prcomp(log_exp_TI %>% t(), center=T, scale=F)
sampleVals_TI<-data.frame(pca_TI$x)
exprVals_TI<-data.frame(pca_TI$rotation)
PoV_TI <- (pca_TI$sdev^2/sum(pca_TI$sdev^2))*100 

coords_TI<-data.frame(sampleVals_TI, Group = TI_samples$Diagnosis,
                   samplename = rownames(sampleVals_TI),
                   Sex = TI_samples$Gender,
                   Site = TI_samples$Intestinal.region,
                   Inflammed = TI_samples$Inflammed, Date=TI_samples$Date) #,
                   #Age = ibd_meta$Age)
coords_TI$Group <- factor(coords_TI$Group, levels = c("Control", "UC", "CD"))
numPCs_TI <- 1:length(PoV_TI)

for (i in 1:length(PoV_TI)) {
    percent <- paste0("(", round(PoV_TI[i],2), "%)")
    name <- paste0("PC", i, "per")
    assign(name, percent)
}

## easy and quick PCA function for manual colour and shape
quick_pca <- function(coords_df, x_PC, y_PC, PoV, shape, fill){
    yaxis <- y_PC
    xaxis <- x_PC
    yperc <- paste0("(", round(PoV[yaxis %>% as.numeric()] ,2), "%)")
    xperc <- paste0("(", round(PoV[xaxis %>% as.numeric()] ,2), "%)")
    yaxislabel <- paste0("PC", yaxis, " ", yperc)
    xaxislabel <- paste0("PC", xaxis, " ", xperc)
    pca_plot <- ggplot(coords_df, aes_string(x = paste0('PC', xaxis), y = paste0('PC', yaxis))) +
        geom_point(size=4, aes_string(shape = shape, color = fill)) + 
        scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
        scale_x_continuous(name=xaxislabel) + 
        scale_y_continuous(name=yaxislabel) +
        theme_bw() +
        theme(legend.position = "right", text=element_text(size=16))
    return(pca_plot)
}
(pc12_TI <- quick_pca(coords_df = coords_TI, x_PC = 2, y_PC = 1, PoV = PoV_TI, shape = "Inflammed", fill = "Group"))

(pc23_TI <- quick_pca(coords_df = coords_TI, x_PC = 2, y_PC = 3, PoV = PoV_TI, shape = "Inflammed", fill = "Group"))

(pc23_TI <- quick_pca_date(coords_df = coords_TI, x_PC = 2, y_PC = 3, PoV = PoV_TI, shape = "Group", fill = "Date"))

#ggsave(filename = "../figs/ms2-pc12-full.pdf", pc12, width = 8, height = 6, units = "in")
```

## UMAP

You refer to these as "projections"

### Descending colon

```{r, message=F, warning=F}
#colnames(log_exp) = colnames(imputed_pep$data)

ms1_umap_DC <- umap(log_exp_DC %>% t(), n_components=4, random_state=2248)
#ibd_meta <- ibd_meta[match(colnames(log_exp), ibd_meta$NewName),]
coords_umap_DC<-data.frame(ms1_umap_DC$layout, Group = DC_samples$Diagnosis,
                   samplename = colnames(log_exp_DC),
                   Sex = DC_samples$Gender,
                   #Site = DC_sample$Intestinal.region,
                   Inflammed = DC_samples$Inflammed, Date=DC_samples$Date)
coords_umap_DC$Group <- factor(coords_umap_DC$Group, levels = c("Control", "UC", "CD"))
labels <- pretty(coords_umap_DC$Date, 5)
(umap_plot_DC <- ggplot(coords_umap_DC, aes(x = X3, y = X2)) +
        geom_point(size=5, aes(shape = Group, color = Date)) + 
        #scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
        scale_color_gradient(
    low="yellow", high="purple", 
    breaks = as.integer(labels), 
    labels = format(labels, "%m/%d/%y")
  ) +
       # scale_x_continuous(name="UMAP1") + 
      #  scale_y_continuous(name="UMAP2") +
        #theme_bw() +
        theme(legend.position = "right", text=element_text(size=16)))

(umap_plot_DC <- ggplot(coords_umap_DC, aes(x = X3, y = X4)) +
        geom_point(size=5, aes(shape = Inflammed, color = Group)) + 
        scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
       # scale_color_gradient(
    #low="yellow", high="purple", 
    #breaks = as.integer(labels), 
    #labels = format(labels, "%m/%d/%y")
  #) +
       # scale_x_continuous(name="UMAP1") + 
      #  scale_y_continuous(name="UMAP2") +
        #theme_bw() +
        theme(legend.position = "right", text=element_text(size=16)))
#umap_plot
#new_clust <- coords_umap %>% filter(X1 < 0 & X2 > 0)

#write.csv(new_clust, file=here::here("ibd", "data", "recentmsruns_cluster.csv"))
```


### Ascending colon

```{r, message=F, warning=F}
#colnames(log_exp) = colnames(imputed_pep$data)

ms1_umap_AC <- umap(log_exp_AC %>% t(), n_components=4, random_state=2248)
#ibd_meta <- ibd_meta[match(colnames(log_exp), ibd_meta$NewName),]
coords_umap_AC<-data.frame(ms1_umap_AC$layout, Group = AC_samples$Diagnosis,
                   samplename = colnames(log_exp_AC),
                   Sex = AC_samples$Gender,
                   #Site = AC_sample$Intestinal.region,
                   Inflammed = AC_samples$Inflammed, Date=AC_samples$Date)
coords_umap_AC$Group <- factor(coords_umap_AC$Group, levels = c("Control", "UC", "CD"))
labels <- pretty(coords_umap_AC$Date, 5)
(umap_plot_AC <- ggplot(coords_umap_AC, aes(x = X1, y = X2)) +
        geom_point(size=5, aes(shape = Group, color = Date)) + 
       # scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
        scale_color_gradient(
          low="yellow", high="purple", 
          breaks = as.integer(labels), 
          labels = format(labels, "%m/%d/%y")
      ) +
       # scale_x_continuous(name="UMAP1") + 
      #  scale_y_continuous(name="UMAP2") +
        #theme_bw() +
        theme(legend.position = "right", text=element_text(size=16)))

(umap_plot_AC <- ggplot(coords_umap_AC, aes(x = X3, y = X2)) +
        geom_point(size=5, aes(shape = Group, color = Date)) + 
        #scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
        scale_color_gradient(
    low="yellow", high="purple", 
    breaks = as.integer(labels), 
    labels = format(labels, "%m/%d/%y")
  ) +
       # scale_x_continuous(name="UMAP1") + 
      #  scale_y_continuous(name="UMAP2") +
        #theme_bw() +
        theme(legend.position = "right", text=element_text(size=16)))


#umap_plot
#new_clust <- coords_umap %>% filter(X1 < 0 & X2 > 0)

#write.csv(new_clust, file=here::here("ibd", "data", "recentmsruns_cluster.csv"))
```


### Terminal illium

```{r, message=F, warning=F}
#colnames(log_exp) = colnames(imputed_pep$data)

ms1_umap_TI <- umap(log_exp_TI %>% t(), n_components=4, random_state=2248)
#ibd_meta <- ibd_meta[match(colnames(log_exp), ibd_meta$NewName),]
coords_umap_TI<-data.frame(ms1_umap_TI$layout, Group = TI_samples$Diagnosis,
                   samplename = colnames(log_exp_TI),
                   Sex = TI_samples$Gender,
                   #Site = TI_sample$Intestinal.region,
                   Inflammed = TI_samples$Inflammed, Date=TI_samples$Date)
coords_umap_TI$Group <- factor(coords_umap_TI$Group, levels = c("Control", "UC", "CD"))
labels <- pretty(coords_umap_TI$Date, 5)
(umap_plot_TI <- ggplot(coords_umap_TI, aes(x = X1, y = X2)) +
        geom_point(size=5, aes(shape = Group, color = Date)) + 
       # scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
        scale_color_gradient(
          low="yellow", high="purple", 
          breaks = as.integer(labels), 
          labels = format(labels, "%m/%d/%y")
      ) +
       # scale_x_continuous(name="UMAP1") + 
      #  scale_y_continuous(name="UMAP2") +
        #theme_bw() +
        theme(legend.position = "right", text=element_text(size=16)))

(umap_plot_TI <- ggplot(coords_umap_TI, aes(x = X3, y = X2)) +
        geom_point(size=5, aes(shape = Group, color = Date)) + 
        #scale_color_manual(values=c("#3444DA",  "#DF737A", "#8C5999", "#00916E", "#D7C0D0", "#FFBA49")) +
        scale_color_gradient(
    low="yellow", high="purple", 
    breaks = as.integer(labels), 
    labels = format(labels, "%m/%d/%y")
  ) +
       # scale_x_continuous(name="UMAP1") + 
      #  scale_y_continuous(name="UMAP2") +
        #theme_bw() +
        theme(legend.position = "right", text=element_text(size=16)))


#umap_plot
#new_clust <- coords_umap %>% filter(X1 < 0 & X2 > 0)

#write.csv(new_clust, file=here::here("ibd", "data", "recentmsruns_cluster.csv"))
```

## Calculating log2 fold change 

We are using [precise-db's](https://github.com/SBRG/precise-db) implementation of robust components in ICA matrix decomposition. This implementation required fold change values. 

We need to write this log2 FC to a file because the ICA implementation is written in Python. 

### All samples

```{r}
ctrl_all <- dplyr::select(log_exp_all, contains("Control"))
ctrl_all$median = apply(ctrl_all, 1, median, na.rm = T)
group_temp_all <- dplyr::select(log_exp_all, -contains("Control"))
ctrl_all<- matrix(ctrl_all$median, nrow=length(ctrl_all$median), ncol=ncol(group_temp_all), byrow=F)

fc_all <- ctrl_all - group_temp_all

all_samples_noctrl <- ibd_meta  %>% dplyr::filter(Diagnosis != "Control")# %>% 
    #mutate(Name = paste0(., "_", Groups))

fc_all <- fc_all %>% dplyr::select(all_samples_noctrl$NewName)
#write.csv(fc_all, here::here("ibd","data", "nc-ibd_ms1_fc-all.csv"), quote=F, row.names = T)
```


### Descending colon

```{r}
ctrl_DC <- dplyr::select(log_exp_DC, contains("Control"))
ctrl_DC$median = apply(ctrl_DC, 1, median, na.rm = T)
group_temp_DC <- dplyr::select(log_exp_DC, -contains("Control"))
ctrl_DC<- matrix(ctrl_DC$median, nrow=length(ctrl_DC$median), ncol=ncol(group_temp_DC), byrow=F)

fc_DC <- ctrl_DC - group_temp_DC

DC_samples_noctrl <- DC_samples  %>% dplyr::filter(Diagnosis != "Control")# %>% 
    #mutate(Name = paste0(., "_", Groups))

fc_DC <- fc_DC %>% dplyr::select(DC_samples_noctrl$NewName)
#write.csv(fc_DC, here::here("ibd","data", "nc-ibd_ms1_fc-DC.csv"), quote=F, row.names = T)
```

### Ascending colon

```{r}
ctrl_AC <- dplyr::select(log_exp_AC, contains("Control"))
ctrl_AC$median = apply(ctrl_AC, 1, median, na.rm = T)
group_temp_AC <- dplyr::select(log_exp_AC, -contains("Control"))
ctrl_AC<- matrix(ctrl_AC$median, nrow=length(ctrl_AC$median), ncol=ncol(group_temp_AC), byrow=F)

fc_AC <- ctrl_AC - group_temp_AC

AC_samples_noctrl <- AC_samples  %>% dplyr::filter(Diagnosis != "Control")# %>% 
    #mutate(Name = paste0(., "_", Groups))

fc_AC <- fc_AC %>% dplyr::select(AC_samples_noctrl$NewName)
#write.csv(fc_AC, here::here("ibd","data", "nc-ibd_ms1_fc-AC.csv"), quote=F, row.names = T)
```

### Terminal Illium

```{r}
ctrl_TI <- dplyr::select(log_exp_TI, contains("Control"))
ctrl_TI$median = apply(ctrl_TI, 1, median, na.rm = T)
group_temp_TI <- dplyr::select(log_exp_TI, -contains("Control"))
ctrl_TI<- matrix(ctrl_TI$median, nrow=length(ctrl_TI$median), ncol=ncol(group_temp_TI), byrow=F)

fc_TI <- ctrl_TI - group_temp_TI

TI_samples_noctrl <- TI_samples  %>% dplyr::filter(Diagnosis != "Control")# %>% 
    #mutate(Name = paste0(., "_", Groups))

fc_TI <- fc_TI %>% dplyr::select(TI_samples_noctrl$NewName)
#write.csv(fc_TI, here::here("ibd","data", "nc-ibd_ms1_fc-TI.csv"), quote=F, row.names = T)
```



## Clustering

Clustering can be completed the following scripts provided in `bin/`. The ICA implementation of precise-db requires a conda environment which can be accessed using `conda activate precise-db`.

Once ICA has completed it's run, you will find `S.csv` (and other relevent files) in your chosen output directory. We will be clustering this matrix using `kmed_clustering.py` This script was written considering the newest versions of used packages, thus, `kmed_clustering.py` also has it's own `conda` environment named `k-med`. 

The following should be run in your terminal and requires `conda` and `python`.

```{zsh engine.opts='-i', eval=F}
## THIS IS A SHELL SCRIPT
## It is best to run this in it's own terminal window because of RStudio's memory limitations 
## biolinux ~/software/MetaProClust-MS1
cd ./bin
# You will need to create a specifsc conda environment for ICA. 
# Uncomment the code below to create the environment
# conda env create -f environment.yml
conda activate precise-db
## script for robust ICA matrix decomposition
## Update -n to as many threads you have available; ideally at least 6 
## However this will run on a laptop with fewer cores, it just may take longer 
sh ./precise-db run_ica.sh -i 100 -t 1e-8 -n 6 -o ../../data/msms/ -l ../../data/msms/ica.log ../../data/msms/ms2_fc.csv
conda deactivate 

# to create the correct conda environment for clustering
#conda env create -f k-med_env.yml
# This k-medoid clustering relies on newer modules than the ica implementation 
conda activate k-med 
./kmed_clutering.py -s ../data/msms/S.csv -n 10 -d ../data/msms/ ## reduce n (number of threads to your needs)
conda deactivate 
```


## Choosing number of clusters

Max silhouette scores are failing on this dataset.

Instead, let's use the inertia scores to choose a k value using the elbow method to see where inertia begins to slow!

```{r message=F, warning=F}
inertia_all <- read.csv(here::here("ibd", "all", "k-med_inertia_all.csv"), header=F) %>% data.frame(inertia = ., k = 2:49)

silhouette_all <- read.csv(here::here("ibd", "all", "k-med_sil_all.csv"), header=F) %>% data.frame(inertia = ., k = 2:49)

ggplot(inertia_all,aes(x=k, y=V1)) +
  geom_line() +
  geom_point(size=3, colour="slateblue") +
  ylab("Inertia")


ggplot(silhouette_all,aes(x=k, y=V1)) +
  geom_line() +
  geom_point(size=3, colour="firebrick2") +
  ylab("Silhouette score")
```

## Cluster eigenfeature calculation and clustering visualization

After we use `Python` for clustering our relatively large dataset, let's calculate summary statistics of each peptide cluster considering the peptide intensity values. We will calculate eigenfactors two ways and compare the two results.


```{r message=F, warning=F}

## I manually chose k=20... is this the best choice?
kmedoid_labels <- read.csv(here::here("ibd", "all", "k-med_labels_k20_all.csv"), header=F) %>% as.vector()

clusterinfopep <- kmedoid_labels %>% data.frame()

max_clust <- kmedoid_labels %>% unique() %>% max()
print(paste("Number of clusters:", max_clust))
fc_clusters <- list()

## making sure our FC data is 
fc_all <- fc_all %>% dplyr::select(noctrlmeta_all$NewName)
## creating a list that contains intensities of each peptide cluster
for (x in 0:max_clust){
    clustername <- paste("Cluster", x)
    y <- kmedoid_labels[which(kmedoid_labels$V1 == x),,drop=F] %>% rownames()
    fc_clusters[[clustername]] <- fc_all[y %>% as.numeric(),]
    fc_clusters[[clustername]]$feat_num <- y 
}

### eigenfactors
### Singular value decomposition for genome-wide expression data processing and modeling
###  https://doi.org/10.1073/pnas.97.18.10101
## https://www.biostars.org/p/299167/
## eigengenes <- svd(X)$v
## We are using PCA
pca_clusters <- lapply(fc_clusters, function(x) prcomp(x %>% dplyr::select(-feat_num) %>% t(), center=T, scale=F)$x)
svd_clusters <- lapply(fc_clusters, function(x) svd(x %>% dplyr::select(-feat_num))$v)
# grabbing the first principal component
svd1_cluster <- lapply(svd_clusters,  "[", , 1)
pc1_cluster <- lapply(pca_clusters,  "[", , 1)
clustereigenfactors_pca <- bind_cols(pc1_cluster) %>% data.frame()
clustereigenfactors_svd <- bind_cols(svd1_cluster) %>% data.frame()
```

Complete the correlation with groups and inflammation. 

```{r message=F, warning=F}
## make a factored dataframe of the compounds
noctrlmeta_all <- ibd_meta %>% filter(Diagnosis != "Control") %>% mutate(group_inflam_location = paste0(Location, "_", Diagnosis, "-", Inflammed))

datTraits <- data.frame(group_inflam_location =  as.factor(noctrlmeta_all$group_inflam_location))
rownames(datTraits) <- noctrlmeta_all$NewName
traits <- model.matrix(~ ., data=datTraits,
                       contrasts.arg = lapply(datTraits, contrasts, contrasts=FALSE))
traits <- traits[,-1] ##removing intercept
#moduleTraitCor_pca <- stats::cor(clustereigenfactors_pca, traits, method = "s")
moduleTraitCor_svd <- stats::cor(clustereigenfactors_svd, traits, method = "s")
#colnames(moduleTraitCor_pca) <- colnames(moduleTraitCor_pca) %>% substr(., 10, nchar(colnames(moduleTraitCor_pca)))
colnames(moduleTraitCor_svd) <- colnames(moduleTraitCor_svd) %>% substr(., 22, nchar(colnames(moduleTraitCor_svd)))
```

Now, let's look at *SVD-derived* eigenfeatures (this is the more common way of calculating an eigenfeature).

```{r, message=F, warning = F}
module_clust_svd <- hclust(as.dist(1-cor(t(moduleTraitCor_svd), method="pearson")), method="average")
drug_clust_svd <- hclust(as.dist(1-cor(moduleTraitCor_svd, method="pearson")), method="average")
drug_clust_boot_svd <- pvclust(moduleTraitCor_svd, method.hclust="average",
                           method.dist="correlation", nboot=1000,
                           iseed=2248)


#quick_sil <- function(hclust_out, distance, max_k){
#  silhouette_score <- function(i){
#    k=cutree(hclust_out,i)
#    ss <- silhouette(k, 1-cor(distance, method="pearson"))
#    mean(ss[, 3])
#    }
#  clustnum <- 2:max_k
#  avg_sil <- sapply(clustnum, silhouette_score)
#  avg_sil <- data.frame(num = clustnum, sil_score = avg_sil)
#  avg_sil <- rbind(c(1,0), avg_sil)
#  return(avg_sil)
#}
#
#ms1_svd_sil <- quick_sil(hclust_out=drug_clust_svd, distance = 1-cor(moduleTraitCor_svd, method="pearson"), max_k = 7) 
#(ms1_sil <- ggplot(ms1_svd_sil, aes(x=num, y = sil_score)) +
#  geom_point(size=4, colour="#F25C54", alpha=1) +
#    geom_line(size=2, alpha=0.4) +
#    geom_vline(xintercept=2, size = 2, linetype="dashed", color = "#38618C") +
#    xlab("Number of clusters") +
#    ylab("Average Silhouette Score") +
#    scale_x_continuous(breaks = 1:30) +
#    theme_classic(base_size=14) +
#    ggtitle("MS1")
#)

## Visualize the bootstrap clusters
clust_boot_svd <- as.dendrogram(drug_clust_boot_svd)
#pdf(here::here("figs", "ms1_bootstrap_dend.pdf"), width=9, height =4)
drug_clust_boot_svd %>% as.dendrogram() %>% plot(main = "MS1")
drug_clust_boot_svd %>% text 
drug_clust_boot_svd %>% pvrect(alpha=0.9, pv="au")
#dev.off()

## colours for dendrogram branches
clust_cols_ms1_svd <- c("#48392A", "#04A777")
## colours for heatmap
new_palette <- colorRampPalette(c("#70A9A1", "white", "#FF9633"))(n=160)

## metadata for clustr heatmap
#"#1446A0",  "#DB3069", "#FFBA08
cor_meta_svd <- data.frame(treatment = colnames(moduleTraitCor_svd)) %>%
    mutate(drug_col = case_when(str_detect(treatment, 'CD-Yes') ~ '#1446A0',
                                str_detect(treatment, 'UC-Yes') ~ '#DB3069',
                                str_detect(treatment, 'UC-No') ~ '#FFBA08',
                                str_detect(treatment, "CD-No") ~ '#5AAA95'
    ))
#range(moduleTraitCor_svd)
# dendrogram for plotting
drug_dend <- color_branches(as.dendrogram(drug_clust_svd), k = 2, col = clust_cols_ms1_svd) %>%
    set("branches_lwd", 3)


## Uncomment to save PDF of heatmap
#pdf(here::here("ibd","figs", "ibd-ms1_heatmap.pdf"), width=9, height=6)
par(xpd = TRUE) # allows legend to be outside "official" plotting lines
coords2 <- list(x=0, y=0.95)
heatmap.2(moduleTraitCor_svd,
          notecol="black",      # change font color of cell labels to black
          density.info="none",  # turns off density plot inside color legend
          trace="none",         # turns off trace lines inside the heat map
          margins =c(5,0),      # widens margins around plot
          col=new_palette,      # 
          breaks=seq(-0.8,0.8,0.01),    # enable color transition at specified limits
          dendrogram="col",     # only draw a row dendrogram
          Colv=drug_dend,            # turn off column clustering
          Rowv=as.dendrogram(module_clust_svd),
          #ColSideColors = cor_meta$drug_col,
          ColSideColors = cor_meta_svd$drug_col,
          labRow = "",
          key.xlab ="Pearson Correlation Coefficient",
          key.title = NA,
          lhei = c(1,4),
          lwid= c(1,3),
          cexCol = 1.2,
          keysize = 1)
legend(coords2, title = "Groups",legend=c("CD-A", "UC-A", "UC-N"), 
       fill=c("#1446A0",  "#DB3069", "#FFBA08"), cex=0.8, box.lty=0)
# Uncomment if you are saving to file
#dev.off()
```

Check out the average intensity levels of clusters with high correlation with CD, UC.
First let's focus on CD.A

```{r}
cor_info <- data.frame(moduleTraitCor_svd)
cor_info[27,]

max_CD.A <- which(clusterinfopep$V1 == which.max(cor_info$CD.A)-1)
max_UC.A <- which(clusterinfopep$V1 == which.max(cor_info$UC.A)-1)
max_UC.N <- which(clusterinfopep$V1 == which.max(cor_info$UC.N)-1)
## set up meta to include inflame with control!
ibd_meta <- ibd_meta %>% mutate(group_inflam = paste0(Groups, "_", inflame),
                                Name = paste0(., "_", Groups)) 

## Make function for this
biomarker_plot <- function(x_group, max_df){
    clust <- log_exp[max_df %>% as.numeric(),]
    clust$feat_num <- max_df
    clust_melt <- clust %>% pivot_longer(!feat_num, names_to="Sample", values_to="log2_intensity") 
    clust_melt <- merge(clust_melt, ibd_meta %>% select(Name, group_inflam), by.x="Sample", by.y="Name")
    clust_melt$group_inflam <- factor(clust_melt$group_inflam, 
                                           levels = c("Control_N", "CD_A", "UC_A", "UC_N"))
    meanvals <- clust_melt %>% group_by(feat_num, group_inflam) %>%
      dplyr::summarize(averageval = mean(log2_intensity, na.rm=TRUE))
    group_spec <- meanvals %>% filter(group_inflam == x_group)
    group_spec <- group_spec[which.max(group_spec$averageval),] #7882
    group_outlier <- meanvals %>% filter(feat_num == group_spec$feat_num)
   
     group_plot<- ggplot(meanvals, aes(x=group_inflam, y=averageval, fill=group_inflam)) + 
    geom_boxplot(alpha=0.7) +
    scale_fill_manual(name = "Groups", values=c("grey", "#1446A0", "#DB3069", "#FFBA08")) +
    geom_line(data = group_outlier, aes(x=group_inflam, y=averageval, group=1),
              colour = "#59C9A5") +
    geom_point(data = group_outlier, aes(x=group_inflam, y=averageval),shape = 21, fill="#59C9A5", colour = "white", size = 4) +
    ylab("Mean log2 intensity value") +
    xlab("Group")
    
     return(group_plot)
}

CD.A_plot <-biomarker_plot(x_group = "CD_A", max_df = max_CD.A)
CD.A_plot
#ggsave(here::here("ibd","figs", "CD_A-clust.png"), CD.A_plot, width=7,
#       height=5, units="in")
```


```{r}
## CD.A 
UC.A_plot <-biomarker_plot(x_group = "UC_A", max_df = max_UC.A)
UC.A_plot
#ggsave(here::here("ibd","figs", "UC_A-clust.png"), UC.A_plot, width=7,
#       height=5, units="in")
```

The most abundant feature is not a good biomarker in this case...

```{r}
max_df = max_UC.N
x_group = "UC_N"
maxfc_biomarker_plot <- function(x_group, max_df){
    clust <- log_exp[max_df %>% as.numeric(),]
    clust$feat_num <- max_df
    clust_melt <- clust %>% pivot_longer(!feat_num, names_to="Sample", values_to="log2_intensity") 
    clust_melt <- merge(clust_melt, ibd_meta %>% select(Name, group_inflam), by.x="Sample", by.y="Name")
    clust_melt$group_inflam <- factor(clust_melt$group_inflam, 
                                           levels = c("Control_N", "CD_A", "UC_A", "UC_N"))
    meanvals <- clust_melt %>% group_by(feat_num, group_inflam) %>%
      dplyr::summarize(averageval = mean(log2_intensity, na.rm=TRUE))
    #group_spec <- meanvals %>% filter(group_inflam == x_group)
    #group_spec <- group_spec[which.max(group_spec$averageval),] #7882
    
    clust_fc <- fc[max_df %>% as.numeric(),]
    clust_fc$feat_num <- max_df
    clust_fc_melt <- clust_fc %>% pivot_longer(!feat_num, names_to="Sample", values_to="log2_fc") 
    clust_fc_melt <- merge(clust_fc_melt, ibd_meta %>% select(Name, group_inflam), by.x="Sample", by.y="Name")
    clust_fc_melt$group_inflam <- factor(clust_fc_melt$group_inflam, 
                                           levels = c("Control_N", "CD_A", "UC_A", "UC_N"))
    meanvals_fc <- clust_fc_melt %>% group_by(feat_num, group_inflam) %>%
      dplyr::summarize(averageval = mean(log2_fc, na.rm=TRUE))
    group_spec_fc <- meanvals_fc %>% filter(group_inflam == x_group)
    group_spec_fc <- group_spec_fc[which.min(group_spec_fc$averageval),] #7882
    
    group_fc_outlier <- meanvals %>% filter(feat_num == group_spec_fc$feat_num)
   
     group_plot<- ggplot(meanvals, aes(x=group_inflam, y=averageval, fill=group_inflam)) + 
    geom_boxplot(alpha=0.7) +
    scale_fill_manual(name = "Groups", values=c("grey", "#1446A0", "#DB3069", "#FFBA08")) +
   geom_line(data = group_fc_outlier, aes(x=group_inflam, y=averageval, group=1),
              colour = "#59C9A5") +
    geom_point(data = group_fc_outlier, aes(x=group_inflam, y=averageval),shape = 21, fill="#59C9A5", colour = "white", size = 4) +
    ylab("Mean log2 intensity value") +
    xlab("Group")
    
     return(group_plot)
}


UC.N_plot <-biomarker_plot(x_group = "UC_N", max_df = max_UC.N)
UC.N_plot
#ggsave(here::here("ibd","figs", "UC_N-clust.png"), UC.N_plot, width=7,
#       height=5, units="in")

UC.N_plot_FC <- maxfc_biomarker_plot(x_group = "UC_N", max_df = max_UC.N)
UC.N_plot_FC
```

# Biomarker discovery through machine learning

The above demonstrates the **potential** to identify biomarkers using this approach. Let's use a more iterative approach by using machine learning. It is likely that we will need to use a combination of many biomarkers (a panel). 

Let's start with UC_A biomarker selection.

It's important to consider we have way more predictors than samples (p >> n). We will need a solution that considers this. Check out these manuscript that may help:

- [-Omics biomarker identification pipeline for translational medicine](https://doi.org/10.1186/s12967-019-1912-5)
- [Statistical predictions with glmnet](https://doi.org/10.1186/s13148-019-0730-1)

"Least Absolute Shrinkage and Selection Operator and Elastic Net feature selection methods are applied to identify the most important features representing potential biomarker candidates"... I think we need to use these as 


**Penalized regression** 
Elastic net (`glmnet`) and lasso can be used for feature selection... let's try them out!


```{r glmnet}
# https://www.r-bloggers.com/2017/09/variable-selection-with-elastic-net/
#x is the data
#y is the response!
# LASSO WITH ALPHA = 1

CD.A_log <- log_exp[max_CD.A,]
## row num is the row we must grab of the filtered data
CD.A_log$row_num <- max_CD.A
## feat number is the actual feature number of the experiment
CD.A_log$feat_num <- rownames(CD.A_log)

ibd_meta_imp <- ibd_meta %>% dplyr::select(Name, group_inflam) %>%
  mutate(CD.A = case_when(group_inflam == "CD_A" ~ 1,
                          group_inflam != "CD_A" ~ 0))
clust27t <- CD.A_log %>% dplyr::select(-ends_with("num")) %>% t() %>% as.data.frame() %>%
  rownames_to_column("Name") %>% 
  left_join(ibd_meta_imp, . , by="Name") %>% dplyr::select(-Name, -group_inflam)

clust27_outcome <- clust27t %>% dplyr::select(CD.A) %>% as.matrix(.)
clust27t <- clust27t %>% dplyr::select(-CD.A) %>% as.matrix(.) 



## change parallel =T when you can...
set.seed(5550)
## this is just a test since we don't have enough samples!
## Change to different nfold
## LASSO
clust27lasso <- cv.glmnet(clust27t, clust27_outcome, family = "binomial", nfold = 4, type.measure = "deviance", paralle = F, alpha = 1)
model1 <- glmnet(clust27t, clust27_outcome, family = "binomial", lambda = clust27lasso$lambda.1se, alpha = 1)
coef(model1, "lambda.min")

## RIDGE
clust27ridge <- cv.glmnet(clust27t, clust27_outcome, family = "binomial", nfold = 4, type.measure = "deviance", paralle = F, alpha = 0)
model2 <- glmnet(clust27t, clust27_outcome, family = "binomial", lambda = clust27ridge$lambda.1se, alpha = 1)
coef(model2, "lambda.min")

## Elastic Net
a <- seq(0.1, 0.9, 0.05)
search <- foreach(i = a, .combine = rbind) %do% { #replace %do% with %dopar%
  cv <- cv.glmnet(clust27t, clust27_outcome, family = "binomial", nfold = 3, type.measure = "deviance", paralle = F, alpha = a)
  data.frame(cvm = cv$cvm[cv$lambda == cv$lambda.1se], lambda.1se = cv$lambda.1se, alpha = i)
}
cv3 <- search[search$cvm == min(search$cvm), ]
md3 <- glmnet(mdlX, mdlY, family = "binomial", lambda = cv3$lambda.1se, alpha = cv3$alpha)
coef(md3)
```

```{r featureid, include=F}
## feature selection (aka selecting good biomarkers!)
## https://machinelearningmastery.com/feature-selection-with-the-caret-r-package/
max_CD.A
log_exp[c(43,155,196),]
CD.A_log <- log_exp[max_CD.A,]
## row num is the row we must grab of the filtered data
CD.A_log$row_num <- max_CD.A
## feat number is the actual feature number of the experiment
CD.A_log$feat_num <- rownames(CD.A_log)

CD.A_cor <- cor(CD.A_log %>% dplyr::select(-ends_with("num"))) 
## want to remove features with higher than 0.75  
CD.A_highcor <- finTIorrelation(CD.A_cor, cutoff=0.75)
## No features are highly correlated,
## This we keep them all.

### stepwise glm logit
#https://www.biostars.org/p/357735/#357739
ibd_meta_imp <- ibd_meta %>% dplyr::select(Name, group_inflam) %>%
  mutate(CD.A = case_when(group_inflam == "CD_A" ~ 1,
                          group_inflam != "CD_A" ~ 0))
clust27t <- CD.A_log %>% dplyr::select(-ends_with("num")) %>% t() %>% as.data.frame() %>%
  rownames_to_column("Name") %>% 
  left_join(ibd_meta_imp, . , by="Name") %>% dplyr::select(-Name, -group_inflam)

null <- glm(CD.A ~ 1, data = clust27t, family = binomial(link = 'logit'))
full <- glm(CD.A ~ .,  data = clust27t, family = binomial(link = 'logit'))


both <- stepAIC(null, scope=list(lower=null, upper=full), direction="both")
forward <- stepAIC(null, scope=list(lower=null, upper=full), direction="forward")
backward <- stepAIC(full, direction="backward")
```